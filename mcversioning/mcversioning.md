## Mc Versioning

Mc Versioning是新版的更新助手，但使用不同的更新方式，与更新助手使用方式有很大不一样，尤其是服务端部分，所以单独取名为Mc Versioning

Mc Versioning相比更新助手，有这些优点：

1. **检测文件速度快**：Mc Versioning使用基于版本号的更新，而非基于同步的更新。基于版本号的更新速度更快。磁盘IO开销更小，对移动端设备更加友好

2. **不用再写更新规则**：更新规则是个很巧妙的设计，但却又是个很反人类的功能，在Mc Versioning中会直接去掉这个辣鸡玩意，程序会自动检测到文件改变，不再需要用更新规则去标明更新范围

3. **玩家可以自行添加模组文件**：更新助手中，玩家自行添加的文件，只要命中更新规则的，都会被客户端无情地删除掉。如果要避免这种情况，只能编写复杂又头疼的更新规则，或者模组文件名加前缀，或者使用规则编辑器。但Mc Versioning不会自作主张删掉这些文件，甚至连在更新的时候，玩家自己添加的文件也能得以保留


Mc Versioning相比更新助手，有这些缺点：

1. 无法检测到玩家对客户端做的修改，具体参考优点三，这个缺点也是更新助手的优点
2. Mc Versioning服务端以命令行为主，图形界面支持暂时为零

Mc Versioning和更新助手共同的优点：

1. 最小化更新策略，即使落下多个版本，也只下载实际需要更新的文件
2. 支持移动端Java版和PC端任意三方启动器

## 使用教程

使用之前需要说明，Mc Versioning的更新方式不同于更新助手，Mc Versioning是采用版本号进行更新的，如果一个客户端的版本是1.7，当服务端发布1.8版本之后，运行客户端程序，客户端会自动更新到1.8版本。如果落后多个版本，客户端程序会依次更新到最新版。

Mc Versioning有3个可执行文件，其中两个是给服务端用的，另外一个是给客户端用的

1. McVersioning.jar：服务端软件，用来管理和打出新的版本包
2. MiniHttpServer.jar：服务端软件：用来开启一个HttpServer供客户端下载
3. McVersioningClient.jar：客户端软件，用来更新客户端文件

### 创建第一个版本

1. 首先在任意位置新建一个文件夹，名字随意，用来存放服务端程序，我这里就叫mvserver
2. 将McVersioning.jar和MiniHttpServer.jar复制到mvserver目录下
3. 双击运行McVersioning.jar程序，程序启动后先最小化到任务栏
4. 可以看到mvserver目录下新增了两个目录client和public
   1. client目录用来存放你要更新的文件，这里也是服主日常维护客户端文件的地方
   2. public目录用来存放你曾经创建的版本，以供给客户端下载。这个目录不要手动修改
5. 将服务端客户端的模组文件复制到mvserver/client/.minecraft/mods/目录下
   1. 注意并不需要复制所有的文件（这点有别于更新助手），你只需要复制你未来可能会更新的文件就好，如果你能非常确定某个模组文件一万年都不需要更新，那么这种文件你就不用复制过去了。当然，一些会自动下载/生成的文件（一般是模组的一些依赖库，某些模组启动时会自动下载，并不需要手动安装）也不需要复制过去。
   2. 这里仅仅拿.minecraft/mods/目录下的模组文件举例子，如果你有其它文件需要更新，也请同样按照上一条步骤进行操作，复制到你想要的路径上就好。请尽量在第一次配置的时候就把需要更新的文件都复制过去，如果忘了复制，后面再发新版本的时候，你是没办法删掉这些忘记加进client里面的文件的。
6. 复制好要更新的文件以后，回到McVersioning窗口，点击`扫描更改`按钮，可以看到下面已经显示你新增了一些文件
7. 点击`版本列表`按钮，在输入框里输入一个版本号比如`1.0`，然后点击`创建版本`按钮，就可以创建出第一个版本了。（版本号可以由任何文字组成，不一定要纯数字，但中文和空格除外！）
8. 版本创建成功之后点击返回，可以看到窗口又显示"没有任何文件修改了"，意思是说client目录现在是干净的
9. 此时你已经发布了第一个版本。接着我们需要开启一个http服务器以供客户端检查更新
10. 在命令行窗口里输入`java -jar MiniHttpServer-0.0.0.jar`可以启动MiniHttpServer这个httpserver
11. 启动成功之后复制API地址后面的链接，粘贴到浏览器打开，如果一切顺利浏览器会显示1.0这个版本号
12. 把McVersioningClient.jar复制到你即将要发布给玩家的服务器客户端文件夹里，放在启动器旁边也就是.minecraft目录的旁边
13. 用压缩软件打开McVersioningClient.jar，把config.yml文件解压到McVersioningClient.jar的旁边，打开config.yml文件进行编辑
14. 将刚刚复制好的API地址粘贴到config.yml中的server选项后面，然后保存关闭
15. 双击运行McVersioningClient.jar，如果一切正常，就会开始更新第一个版本，更新完成后客户端的版本号会保存在mv-version.txt里面，默认放在程序旁边，如果要调整文件位置，可以修改配置文件

### 创建第二第三个版本

有别于初次创建第一个版本，创建第二第三个版本要容易的多。如果你的客户端要更新文件了，只需要很简单的几个步骤就能轻松完成

1. 在给client目录更换新的文件或者进行修改之前，首先需要确认一下client目录是干净的，也就是client目录没有被改过的，因为你也不想在打新版本时，打进一些奇奇怪怪的东西进去对吧？
2. 双击运行McVersioning.jar程序，程序启动后会自动检查client目录的修改情况，如果你不放心，可以再手动点一次`扫描更改`来确认一遍
3. 理想情况下，client目录不应该有任何文件修改。如果要丢弃这些修改，可以点击`还原更改`按钮来使client目录恢复原状，请注意这个命令可能会丢弃你对client目录的一切更改，使用前请十分注意！

1. 确保client目录是干净的以后，你就可以对client目录下的文件做替换了，该换新版的文件换新版，该修改的文件修改，该新增的新增，该删除的删除

2. 完成之后，点击`版本列表`然后重新打一个新的版本就完成了。这样，一个新的版本就创建好了

   注意版本号一旦发布就不能撤回了，因为撤回会导致文件状态混乱。你应该额外发布一个更新的版本来替代撤回以修补你的过错

## 文件用途介绍

Mc Versioning在运行时会创建许多文件，本章节会主要介绍这些文件的用途，尤其是public目录下的文件

public目录下的文件一般不建议手动修改，如特殊情况确实要手动修改，请在修改之前详细阅读本章节的文件说明。如果你在使用软件的时候出现了一些不可逆转的错误，请尽量直接删除整个public目录重头来过，而非进来手动修改文件

### public/snapshot目录

这个目录用来存储client目录的最新快照。有两个用途：一是用来给客户端提供文件更新下载，二是用来丢弃你对client目录的更改的。此目录由程序自动维护，非特殊情况请勿手动修改

### public/snapshot.json文件

这个文件用来存储snapshot目录下的文件结构信息，正常情况下此文件内容应该和snapshot目录的文件结构保持一致。此外这个文件也被用来计算与client目录的差异，以此来得知你对client目录都做了哪些修改。此文件由程序自动维护，非特殊情况请勿手动修改

### public/all-versions.txt文件

这个文件存储着迄今为止你创建的所有版本号，用来给客户端判断落后服务端多少个版本。此文件由程序自动维护，非特殊情况请勿手动修改

### public/current-version.txt文件

这个文件存储着最新的版本号，用来给客户端快速判断客户端是否需要更新，如果需要更新，则客户端会再次获取all-versions.txt文件判断具体落下了哪些更新。此文件由程序自动维护，非特殊情况请勿手动修改

### v-x.x.x.json文件

x.x.x代表一个实际的版本号。这是一个版本记录文件，是存储每个版本里的文件变化的文件，也就是每个版本你都新增了哪些文件，修改了哪些文件，删除了哪些文件之类的，每一个版本都是一个单独的文件。此文件由程序自动维护，非特殊情况请勿手动修改

## 凭空删除文件

如果某些文件在你打包第一个版本的时候，忘记复制进client目录了，那么这个这个文件就不能通过删除client目录里的这个文件来实现在客户端也删掉这个文件了。因为client目录里面根本就没有这个文件，所以删不了。

如果你要删除某个在客户端有，但在client目录里没有的文件。首先需要打一个新的版本。然后编辑对应的版本记录文件，也就是public/v-xxx.json

打开文件后，在old_files字段下手动添加上你要删除的文件的相对路径就可以了。如果要删除目录，请添加在old_folders下。等到客户端更新到这个版本的时候，就会自动删除这些old_files下的文件和old_folders下的目录了

## 一些使用提示

版本号不强制需要往高迭代，也可以往低迭代，就是说你甚至可以1.5版本更新到1.4版本，这都被允许的。因为版本的前后关系并不是直接判断版本号文字计算出来的，而是按照你打每个版本的时间顺序，后打的版本总是比先打的版本要新（存储在public/all-versions.txt里）版本号文字只是个标签罢了，不作为任何判断版本前后的依据
